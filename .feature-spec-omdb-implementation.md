# Feature Implementation: OMDB Provider

**Status**: Planning Complete â†’ Ready for Implementation
**Branch**: feature/omdb-provider-research
**Created**: 2025-11-21
**Based On**: Empirical testing (100% reliability for movies) + Architecture analysis

---

## Implementation Decisions

### User Requirements (Confirmed)

1. âœ… **No embedded API key** - User must provide in GUI
2. âœ… **Enabled if API key present** - Configured in GUI, not environment variables
3. âœ… **No rate limit warnings in UI** - Keep it simple
4. âœ… **Poster resolution as-is** - 300px, scoring will rank them lower naturally
5. âœ… **Implement TV series support** - Other providers support series, OMDB should too

### Technical Decisions

1. **Field-Level Merging**: Simple approach (Option A)
   - Add OMDB ratings to existing ratings array
   - No complex field-level priority merge logic yet
   - TMDB remains authoritative for other fields
   - Future enhancement: Full field-level priority system

2. **Provider Registration**:
   - Self-registration pattern (like TMDB/TVDB)
   - Default: `enabled=false` (no API key)
   - GUI sets `enabled=true` when user adds key

3. **Entity Support**:
   - Movies: Fully supported
   - Series: Fully supported
   - Episodes: Supported (OMDB can fetch by season/episode)

4. **Asset Types**:
   - Posters: Yes (300px, low priority)
   - Other assets: No (OMDB doesn't provide)

5. **Caching**:
   - Automatic via `ProviderCacheManager`
   - 7-day TTL (same as other providers)
   - Cache table: `provider_assets`

---

## Implementation Tasks

### Phase 1: Core Provider Implementation

#### Task 1: Create OMDBClient (~150 lines, 2 hours)
**File**: `src/services/providers/omdb/OMDBClient.ts`

**Requirements**:
- Axios-based HTTP client
- Circuit breaker integration (inherit from BaseProvider)
- Retry strategy for network errors
- Rate limiter (1000 req/day free, 100K req/day paid)

**Methods**:
```typescript
class OMDBClient {
  async search(query: string, type: 'movie' | 'series'): Promise<OMDBSearchResult[]>
  async getById(imdbId: string, plot: 'short' | 'full'): Promise<OMDBResponse>
  async getByTitle(title: string, year?: number): Promise<OMDBResponse>
  async getEpisode(imdbId: string, season: number, episode: number): Promise<OMDBEpisodeResponse>
}
```

**Error Handling**:
- Parse OMDB error responses: `{ Response: "False", Error: "..." }`
- Map to Metarr error types:
  - `Invalid API key!` â†’ AuthenticationError
  - `Movie not found!` â†’ ResourceNotFoundError
  - `Daily limit reached!` â†’ RateLimitError
- Circuit breaker on 5 consecutive failures

**Response Validation**:
- Check for "N/A" values
- Calculate completeness (% of fields populated)
- Reject if <60% complete (configurable threshold)

---

#### Task 2: Create OMDBProvider (~250 lines, 3 hours)
**File**: `src/services/providers/omdb/OMDBProvider.ts`

**Requirements**:
- Extend `BaseProvider` abstract class
- Support movies, series, and episodes
- No API key = disabled automatically

**Capabilities Definition**:
```typescript
defineCapabilities(): ProviderCapabilities {
  return {
    id: 'omdb',
    name: 'OMDb API',
    version: '1.0.0',
    category: 'metadata',

    supportedEntityTypes: ['movie', 'series', 'episode'],

    supportedMetadataFields: {
      movie: ['title', 'plot', 'ratings', 'releaseDate', 'runtime', 'genres',
              'directors', 'writers', 'actors', 'certification', 'awards'],
      series: ['title', 'plot', 'ratings', 'premiered', 'genres', 'actors'],
      episode: ['title', 'plot', 'directors', 'writers', 'actors'],
    },

    supportedAssetTypes: {
      movie: ['poster'],
      series: ['poster'],
      episode: [],
    },

    authentication: {
      type: 'api_key',
      required: true,  // No embedded key
      configLocation: 'gui',  // Configured in GUI, not env
    },

    rateLimit: {
      requestsPerSecond: 0.011, // 1000 per day = ~0.69 per minute
      burstCapacity: 5,
      webhookReservedCapacity: 0,
      enforcementType: 'client',
    },

    search: {
      supported: true,
      fuzzyMatching: true,
      externalIdLookup: ['imdb_id'],
    },

    dataQuality: {
      metadataCompleteness: 1.0,  // 100% from empirical testing
      imageQuality: 0.3,  // Low-res posters (300px)
      updateFrequency: 'daily',
      userContributed: true,
      curatedContent: false,
    },
  };
}
```

**Methods to Implement**:

```typescript
// Search for movies/series by title
async search(request: SearchRequest): Promise<SearchResult[]>

// Get detailed metadata
async getMetadata(request: MetadataRequest): Promise<MetadataResponse>

// Get asset candidates (posters only)
async getAssets(request: AssetRequest): Promise<AssetCandidate[]>

// Test API key validity
async testConnection(): Promise<TestConnectionResponse>
```

**Field Mapping** (OMDB â†’ Metarr):
```typescript
fields: {
  title: omdb.Title,
  plot: omdb.Plot !== 'N/A' ? omdb.Plot : undefined,
  releaseDate: omdb.Released !== 'N/A' ? parseDate(omdb.Released) : undefined,
  runtime: omdb.Runtime !== 'N/A' ? parseRuntime(omdb.Runtime) : undefined,
  genres: omdb.Genre !== 'N/A' ? omdb.Genre.split(', ') : [],
  directors: omdb.Director !== 'N/A' ? omdb.Director.split(', ') : [],
  writers: omdb.Writer !== 'N/A' ? omdb.Writer.split(', ') : [],
  actors: omdb.Actors !== 'N/A' ? omdb.Actors.split(', ') : [],
  certification: omdb.Rated !== 'N/A' ? omdb.Rated : undefined,
  awards: omdb.Awards !== 'N/A' ? omdb.Awards : undefined,

  // Ratings: IMDb + Rotten Tomatoes + Metacritic
  ratings: [
    {
      source: 'imdb',
      value: parseFloat(omdb.imdbRating),
      votes: parseInt(omdb.imdbVotes.replace(/,/g, '')),
      maxValue: 10,
    },
    ...parseAdditionalRatings(omdb.Ratings),  // RT, MC
  ],
}
```

**No API Key Handling**:
```typescript
constructor(config: ProviderConfig) {
  super(config);

  if (!config.apiKey || config.apiKey === '') {
    this.enabled = false;
    logger.info('OMDB provider disabled: No API key configured. Get one at https://www.omdbapi.com/apikey.aspx');
    return;
  }

  this.omdbClient = new OMDBClient(config.apiKey);
  this.enabled = true;
}
```

---

#### Task 3: Provider Registration (~30 lines, 30 minutes)
**File**: `src/services/providers/omdb/register.ts`

```typescript
import { ProviderRegistry } from '../ProviderRegistry.js';
import { OMDBProvider } from './OMDBProvider.js';

export function registerOMDBProvider(registry: ProviderRegistry): void {
  registry.registerProvider('omdb', {
    factory: (config) => new OMDBProvider(config),
    defaultConfig: {
      id: 'omdb',
      name: 'OMDb API',
      enabled: false,  // Disabled until user adds API key
      apiKey: '',      // No embedded key
      priority: 3,     // Lower than TMDB (1) and Fanart.tv (2)
    },
  });

  logger.info('OMDB provider registered');
}
```

**Update**: `src/services/providers/index.ts`
```typescript
import { registerOMDBProvider } from './omdb/register.js';

// ... existing imports ...

export function registerAllProviders(registry: ProviderRegistry): void {
  registerTMDBProvider(registry);
  registerTVDBProvider(registry);
  registerFanArtProvider(registry);
  registerIMDbProvider(registry);
  registerLocalProvider(registry);
  registerOMDBProvider(registry);  // ADD THIS
}
```

---

#### Task 4: Provider Metadata Configuration (~40 lines, 30 minutes)
**File**: `src/config/providerMetadata.ts`

```typescript
export const PROVIDER_METADATA: Record<string, ProviderMetadata> = {
  // ... existing providers ...

  omdb: {
    id: 'omdb',
    name: 'OMDb',
    displayName: 'OMDb API',
    description: 'Open Movie Database - IMDb ratings, Rotten Tomatoes, Metacritic',

    requiresApiKey: true,
    apiKeyUrl: 'https://www.omdbapi.com/apikey.aspx',
    apiKeyInstructions: 'Free tier: 1,000 requests/day. Paid tier: $1/month for 100,000/day.',

    baseUrl: 'https://www.omdbapi.com',

    rateLimit: {
      free: { requests: 1000, windowSeconds: 86400 },      // 1000/day
      paid: { requests: 100000, windowSeconds: 86400 },    // 100K/day
    },

    supportedEntityTypes: ['movie', 'series', 'episode'],

    supportedAssetTypes: [
      {
        type: 'poster',
        displayName: 'Posters',
        description: 'Low-resolution (300px) posters from Amazon',
        available: true,
        qualityNote: 'Lower quality than TMDB/Fanart.tv',
      },
    ],

    strengths: [
      'Authoritative IMDb ratings and vote counts',
      'Only source for Rotten Tomatoes scores',
      'Only source for Metacritic scores',
      'Only source for Awards information',
      '100% reliable for popular movies (tested)',
    ],

    limitations: [
      'No trailers (use TMDB)',
      'Low-resolution posters (300px)',
      'No fanart, clearlogos, or other artwork',
      'Rate limit: 1,000/day free tier',
      'TV episode data untested (may be incomplete)',
    ],
  },
};
```

**Default Priority Configuration**:
```typescript
export const DEFAULT_PRIORITY_PRESET: PriorityPreset = {
  name: 'Quality First',

  metadataFieldPriorities: {
    // OMDB primary for ratings (has RT/MC)
    ratings: ['omdb', 'tmdb', 'tvdb'],

    // OMDB supplementary for awards
    awards: ['omdb'],

    // TMDB primary for everything else
    plot: ['tmdb', 'omdb', 'tvdb'],
    actors: ['tmdb', 'omdb', 'tvdb'],
    directors: ['tmdb', 'omdb', 'tvdb'],
    genres: ['tmdb', 'omdb', 'tvdb'],
    // ... etc
  },

  assetTypePriorities: {
    // OMDB lowest priority (low-res)
    poster: ['fanart_tv', 'tmdb', 'tvdb', 'omdb', 'local'],
    fanart: ['fanart_tv', 'tmdb', 'tvdb', 'local'],
    trailer: ['tmdb', 'tvdb'],  // OMDB doesn't provide trailers
  },
};
```

---

### Phase 2: Testing

#### Task 5: Unit Tests (~150 lines, 2 hours)
**File**: `tests/providers/OMDBProvider.test.ts`

**Test Cases**:
```typescript
describe('OMDBProvider', () => {
  describe('Constructor', () => {
    it('should disable provider if no API key', () => {
      const provider = new OMDBProvider({ apiKey: '' });
      expect(provider.enabled).toBe(false);
    });

    it('should enable provider if API key present', () => {
      const provider = new OMDBProvider({ apiKey: 'test-key' });
      expect(provider.enabled).toBe(true);
    });
  });

  describe('search()', () => {
    it('should search movies by title', async () => {
      mockAxios.onGet().reply(200, mockSearchResponse);
      const results = await provider.search({ query: 'Matrix', entityType: 'movie' });
      expect(results.length).toBeGreaterThan(0);
    });

    it('should return empty array if no API key', async () => {
      const provider = new OMDBProvider({ apiKey: '' });
      const results = await provider.search({ query: 'Matrix', entityType: 'movie' });
      expect(results).toEqual([]);
    });
  });

  describe('getMetadata()', () => {
    it('should fetch movie metadata by IMDb ID', async () => {
      mockAxios.onGet().reply(200, mockMovieResponse);
      const result = await provider.getMetadata({
        providerResultId: 'tt0133093',
        entityType: 'movie'
      });
      expect(result.fields.title).toBe('The Matrix');
      expect(result.fields.ratings.length).toBeGreaterThan(0);
    });

    it('should parse all rating sources', async () => {
      const result = await provider.getMetadata({ ... });
      const sources = result.fields.ratings.map(r => r.source);
      expect(sources).toContain('imdb');
      expect(sources).toContain('rottentomatoes');
      expect(sources).toContain('metacritic');
    });

    it('should handle "N/A" values', async () => {
      mockAxios.onGet().reply(200, { ...mockResponse, Plot: 'N/A' });
      const result = await provider.getMetadata({ ... });
      expect(result.fields.plot).toBeUndefined();
    });
  });

  describe('getAssets()', () => {
    it('should return poster URL', async () => {
      mockAxios.onGet().reply(200, mockMovieResponse);
      const assets = await provider.getAssets({
        providerResultId: 'tt0133093',
        entityType: 'movie',
        assetType: 'poster'
      });
      expect(assets.length).toBe(1);
      expect(assets[0].assetType).toBe('poster');
      expect(assets[0].url).toContain('amazon');
    });

    it('should return empty array if poster is "N/A"', async () => {
      mockAxios.onGet().reply(200, { ...mockResponse, Poster: 'N/A' });
      const assets = await provider.getAssets({ ... });
      expect(assets).toEqual([]);
    });
  });

  describe('Error Handling', () => {
    it('should throw AuthenticationError for invalid API key', async () => {
      mockAxios.onGet().reply(200, { Response: 'False', Error: 'Invalid API key!' });
      await expect(provider.getMetadata({ ... })).rejects.toThrow(AuthenticationError);
    });

    it('should throw ResourceNotFoundError for not found', async () => {
      mockAxios.onGet().reply(200, { Response: 'False', Error: 'Movie not found!' });
      await expect(provider.getMetadata({ ... })).rejects.toThrow(ResourceNotFoundError);
    });

    it('should throw RateLimitError for daily limit', async () => {
      mockAxios.onGet().reply(200, { Response: 'False', Error: 'Daily limit reached!' });
      await expect(provider.getMetadata({ ... })).rejects.toThrow(RateLimitError);
    });
  });
});
```

---

#### Task 6: Integration Test with Real API (Optional, 30 minutes)
**File**: `tests/integration/omdb.integration.test.ts`

**Requirements**:
- Requires real OMDB API key in test environment
- Only run in CI pipeline (skip locally)
- Test against known movie (The Matrix)

---

### Phase 3: Documentation

#### Task 7: Provider Documentation (~150 lines, 1 hour)
**File**: `docs/providers/OMDB.md`

**Sections**:
1. Overview
2. Getting an API Key
3. Configuration
4. Supported Features
5. Limitations
6. Rate Limits
7. Data Quality
8. Comparison with Other Providers
9. Troubleshooting

**See**: Template from `docs/providers/TMDB.md`

---

#### Task 8: Update Central Documentation (~30 lines, 30 minutes)

**Files to Update**:
1. `docs/providers/OVERVIEW.md` - Add OMDB to provider matrix
2. `docs/providers/GETTING_API_KEYS.md` - Add OMDB section
3. `docs/architecture/PROVIDER_CACHE_MANAGER.md` - Mention OMDB caching
4. `README.md` - Add OMDB to supported providers list

---

### Phase 4: Frontend Integration (If Needed)

#### Task 9: Provider Configuration UI (Check if Exists)

**Verify**: Does GUI already support adding custom provider API keys?

**Check**: `public/frontend/src/components/provider/ProviderConfigModal.tsx`

**If NOT exists**: Create UI for API key configuration
- Provider enable/disable toggle
- API key input field
- Test connection button
- Tier selection (free/paid)

**If exists**: Ensure OMDB shows up automatically when registered

---

## Implementation Checklist

### Code Files (6 files to create)
- [ ] `src/services/providers/omdb/OMDBClient.ts` (~150 lines)
- [ ] `src/services/providers/omdb/OMDBProvider.ts` (~250 lines)
- [ ] `src/services/providers/omdb/register.ts` (~30 lines)
- [ ] `src/services/providers/omdb/index.ts` (~5 lines, exports)
- [ ] `tests/providers/OMDBProvider.test.ts` (~150 lines)
- [ ] `tests/integration/omdb.integration.test.ts` (~50 lines, optional)

### Configuration Files (2 files to modify)
- [ ] `src/config/providerMetadata.ts` (+40 lines)
- [ ] `src/services/providers/index.ts` (+2 lines)

### Documentation Files (5 files)
- [ ] `docs/providers/OMDB.md` (new, ~150 lines)
- [ ] `docs/providers/OVERVIEW.md` (update)
- [ ] `docs/providers/GETTING_API_KEYS.md` (update)
- [ ] `docs/architecture/PROVIDER_CACHE_MANAGER.md` (update)
- [ ] `README.md` (update)

### Pre-Implementation Verification
- [ ] Review `BaseProvider` abstract class to understand interface
- [ ] Review `TMDBProvider` as reference implementation
- [ ] Review `ProviderRegistry` registration pattern
- [ ] Understand `ProviderCacheManager` caching flow

### Pre-Merge Verification (MANDATORY)
- [ ] TypeScript compiles (`npm run typecheck`)
- [ ] ESLint passes (`npm run lint`)
- [ ] Backend builds (`npm run build`)
- [ ] Frontend builds (`npm run build:frontend`)
- [ ] All tests pass (`npm test`)
- [ ] Manual testing: Add OMDB API key in GUI
- [ ] Manual testing: Fetch metadata for The Matrix
- [ ] Manual testing: Verify ratings include IMDb + RT + Metacritic
- [ ] Manual testing: Verify poster appears (300px, low quality)
- [ ] Manual testing: Disable OMDB, verify graceful skip

---

## Success Criteria

- [ ] OMDB provider can be enabled/disabled in GUI
- [ ] Provider disabled automatically if no API key
- [ ] Provider gracefully skipped by FetchOrchestrator if disabled
- [ ] Metadata fetching works for movies (tested: The Matrix)
- [ ] Metadata fetching works for TV series (tested: Breaking Bad)
- [ ] Ratings array includes IMDb, Rotten Tomatoes, Metacritic
- [ ] Awards field populated from OMDB
- [ ] Posters returned (300px), scored lower than TMDB/Fanart.tv
- [ ] Results cached in `provider_assets` table (7-day TTL)
- [ ] Circuit breaker opens on 5 consecutive failures
- [ ] Rate limit errors handled gracefully
- [ ] Invalid API key shows clear error message
- [ ] All tests pass
- [ ] Documentation complete

---

## Estimated Effort

**Total**: 10-14 hours

**Breakdown**:
- OMDBClient: 2 hours
- OMDBProvider: 3 hours
- Registration/Config: 1 hour
- Tests: 2 hours
- Documentation: 1.5 hours
- Integration testing: 1 hour
- Bug fixes/polish: 2-3 hours

---

## Implementation Order

1. âœ… Research complete (empirical testing, architecture analysis)
2. ðŸ”„ **Next**: Create OMDBClient (foundation)
3. Create OMDBProvider (core implementation)
4. Register provider (integration)
5. Configure priorities (metadata)
6. Write tests (validation)
7. Documentation (user-facing)
8. Manual testing (QA)
9. Pre-merge checks (quality)
10. Merge to main (deployment)

---

## Notes

- No embedded API key = provider is opt-in only
- GUI configuration ensures user controls enablement
- Poster resolution workaround not needed (scoring handles quality)
- TV series support included (same as other providers)
- Field-level priority merge = future enhancement (not now)
- Rate limit warnings = not needed (keep UI simple)

---

## Ready to Proceed?

All planning complete. Implementation can begin immediately.

**Next command**: Spawn implementation agents to create OMDBClient, OMDBProvider, and tests in parallel.
