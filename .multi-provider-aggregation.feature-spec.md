# Multi-Provider Metadata Aggregation - Feature Specification

**Status**: Planning Complete - Ready for Implementation
**Branch**: `feature/metadata-completeness`
**Target Version**: v2.0
**Created**: 2025-11-21
**Updated**: 2025-11-22

---

## Executive Summary

Implement a robust multi-provider metadata enrichment system that:
1. **Never loses data** - "Fill gaps, don't erase" principle
2. **Adapts automatically** - Detects rate limits by testing, not counting
3. **Provides two enrichment modes** - Best effort (single movie) vs. complete data (bulk)
4. **Integrates OMDB** - Authoritative IMDb ratings, RT scores, Metacritic

**Core Philosophy**: Simple, resilient, adaptive - the system should "just work" without user configuration.

---

## Problem Statement

### Current Issues

1. **OMDB Not Integrated** - Provider exists but not wired into enrichment flow
2. **Data Regression Risk** - Empty provider responses can overwrite existing values
3. **Rate Limit Failures** - Single provider failure blocks entire enrichment
4. **Fixed Batch Size** - Arbitrary limits don't adapt to API tier or cache state
5. **No Completeness Tracking** - Users can't see which fields are missing

### Key Decisions Made

Throughout the planning process, we made several critical decisions to simplify the system:

#### Decision 1: "Fill Gaps, Don't Erase"
**Problem**: Provider temporarily returns null → overwrites existing data → data loss
**Solution**: Never replace a value with null/empty
```typescript
currentValue: "A computer hacker..."
newValue: null (OMDB rate-limited)
→ Action: SKIP UPDATE (keep existing value)
```

#### Decision 2: No Source Tracking
**Rejected**: Storing which provider supplied each field (`_sources` object)
**Reason**: Adds complexity without proportional value. Simple field comparison achieves same goal.
```typescript
// Rejected (complex):
{ plot: "...", plot_source: "omdb", plot_fetched_at: "..." }

// Accepted (simple):
{ plot: "..." }
```

#### Decision 3: No Thrashing Prevention via Completion Tracking
**Rejected**: Only update database when ALL providers respond
**Reason**: Permanent provider death would block all enrichment forever
**Solution**: Allow updates with partial data, rely on "fill gaps" logic to prevent regression

#### Decision 4: Dynamic Batch Size (Not Fixed)
**Rejected**: Fixed 100 items/day
**Reason**: Doesn't adapt to API tier (free 1k vs paid 100k) or cache state
**Solution**: Process ALL movies until rate limit detected, then stop
```
Free tier: Processes ~1000 movies → hits limit → stops
Paid tier: Processes 100K movies → never hits limit → completes
(No config change needed)
```

#### Decision 5: Two Enrichment Modes
**Problem**: Webhooks need immediate data (partial OK), scheduled jobs need complete data
**Solution**:
- **Single movie** (webhook/manual): Best attempt, use partial data
- **Bulk enrichment** (scheduled): Complete data or skip entire job

#### Decision 6: Hardcoded Provider Priority (Not DB-Driven)
**Rejected**: Database table for field authorities and provider priority
**Reason**: Adds complexity, rarely changes, easier to maintain in code
**Solution**: Hardcoded priority: OMDB > TMDB > Fanart
```typescript
const PROVIDER_PRIORITY = ['omdb', 'tmdb', 'fanart'];
```

---

## OMDB Rate Limit Behavior (Research Findings)

### Critical Discovery: OMDB Doesn't Return HTTP 429

**Standard API Behavior**:
```http
HTTP/1.1 429 Too Many Requests
Retry-After: 3600
```

**OMDB Actual Behavior**:
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "Response": "False",
  "Error": "Request limit reached!"
}
```

**Implications**:
- Cannot rely on HTTP status code
- Must check response body: `Response === "False" && Error.includes("Request limit")`
- Requires provider-specific rate limit detection

**Free Tier**: 1,000 requests per 24 hours
**Paid Tier**: 100,000 requests per 24 hours
**Reset Time**: Unknown (not documented), handled by daily scheduled retries

---

## Core Features

### 1. "Fill Gaps, Don't Erase" Logic

**Per-Field Update Decision**:

```typescript
function shouldUpdateField(
  currentValue: any,
  newValue: any,
  fieldLocked: boolean
): boolean {
  // User locked this field → never update
  if (fieldLocked) {
    return false;
  }

  // Current is empty → accept any non-empty value (FILL GAP)
  if (currentValue == null || currentValue === '') {
    return newValue != null && newValue !== '';
  }

  // Current has value, new is empty → REJECT (PREVENT REGRESSION)
  if (newValue == null || newValue === '') {
    return false;
  }

  // Both have values → allow update if different (ALLOW CHANGES)
  return currentValue !== newValue;
}
```

**Examples**:

| Current | New | Locked | Result | Reason |
|---------|-----|--------|--------|--------|
| `null` | `"A hacker..."` | No | ✅ Update | Fill gap |
| `"A hacker..."` | `null` | No | ❌ Skip | Prevent regression |
| `"A hacker..."` | `"Neo discovers..."` | No | ✅ Update | Allow change (OMDB updated plot) |
| `8.7` | `8.8` | No | ✅ Update | Allow change (rating changed) |
| `"User edit"` | `"New value"` | Yes | ❌ Skip | Respect lock |

---

### 2. Two-Mode Enrichment System

#### Mode 1: Single Movie Enrichment ("Best Attempt")

**Triggers**:
- User clicks "Refresh Metadata" button (manual)
- Webhook from Radarr/Sonarr (automatic job creation)

**Behavior**:
- Use partial data (some providers rate-limited = OK)
- Goal: Get THIS movie enriched NOW
- Proceeds to pipeline phases (publishing, player sync)

**Example Flow**:
```
Radarr Webhook: New movie "Inception" downloaded
  ↓
Webhook Handler: Create job "enrich-movie" (entityId: 123)
  ↓
Job Queue: Process enrichment (requireComplete: false)
  ↓
Fetch Providers:
  - TMDB: ✓ Success (plot, poster, cast)
  - OMDB: ✗ Rate limited (skip)
  - Fanart: ✓ Success (clearlogo, fanart)
  ↓
Apply "fill gaps" logic → Update movie with TMDB + Fanart
  ↓
Trigger Pipeline:
  - Publishing phase → Deploy assets to library
  - Player sync phase → Update Kodi/Jellyfin
  - Notification phase → Alert user
  ↓
Result: User sees movie with plot, poster, artwork
        (IMDb rating missing, but movie is usable)
```

#### Mode 2: Bulk Enrichment ("Complete or Skip")

**Triggers**:
- Scheduled daily job (3am)

**Behavior**:
- Stop if ANY provider rate-limited
- Don't update partial data (wait for tomorrow)
- Goal: Complete enrichment or nothing

**Example Flow**:
```
Scheduled Job: 3am daily
  ↓
Query: All monitored movies (ORDER BY id ASC)
  ↓
For Each Movie:
  ↓
  Movie 1-500:
    - All providers ✓ Success
    - Update with complete data
  ↓
  Movie 501:
    - TMDB: ✓ Success
    - OMDB: ✗ Rate limited (Response: "False", Error: "Request limit reached!")
    - Fanart: ✓ Success
    ↓
    Result: STOP entire job (don't update movie 501)
  ↓
Movies 502-1000: Not processed (try again tomorrow)
  ↓
Tomorrow at 3am:
  - OMDB limit may have reset
  - Try again from movie 501
  - If limit reset → process all remaining movies
```

**Why This Works**:
- Cache TTL (7 days) means movies 1-500 are cache hits tomorrow
- Only movies 501-1000 make API calls
- If OMDB reset → complete data for all movies
- If OMDB still limited → stop immediately (1 request wasted)

---

### 3. Dynamic Batch Processing with Cache Efficiency

**Key Insight**: Cache makes processing order irrelevant

**Example: 1000 Movies, Free Tier (1000 req/day)**

```
Day 1 (Initial Scan):
  - All cache misses
  - Process 1000 movies → 1000 API calls
  - Hit OMDB limit at movie 1000
  - Result: All movies enriched (may be missing OMDB data)

Day 2-7 (Daily Runs):
  - Movies 1-857: Cache hits (< 24 hours old) → 0 API calls
  - Movies 858-1000: Cache stale → 143 API calls
  - OMDB limit: 143/1000 used
  - Result: All movies stay fresh, never hit limit

Day 8+:
  - Continuous rotation through library
  - ~143 API calls per day (1000 movies / 7 days)
  - Stays well under 1000/day limit
```

**Example: 100K Movies, Paid Tier (100K req/day)**

```
Day 1:
  - Process 100K movies → 100K API calls
  - Never hits limit
  - Result: All movies enriched completely

Day 2-7:
  - ~14,300 API calls per day (100K / 7)
  - Never hits limit
  - Result: All 100K movies stay fresh
```

**Automatic Adaptation**:
- Free tier user upgrades to paid → system automatically processes more movies
- No configuration change needed
- Rate limit detection is test-based, not count-based

---

### 4. Provider Priority & Aggregation

**Hardcoded Priority** (simple, maintainable):

```typescript
const PROVIDER_PRIORITY = ['omdb', 'tmdb', 'fanart'];

function aggregateMetadata(responses: ProviderResponse[]): Metadata {
  const result = {};

  for (const field of ALL_FIELDS) {
    // Try providers in priority order
    for (const providerId of PROVIDER_PRIORITY) {
      const provider = responses.find(r => r.provider === providerId);
      const value = provider?.data?.[field];

      // Found non-empty value → use it
      if (value != null && value !== '') {
        result[field] = value;
        break;  // Move to next field
      }
    }
  }

  return result;
}
```

**Priority Rationale**:
1. **OMDB First**: Authoritative IMDb ratings, RT scores, Metacritic, awards
2. **TMDB Second**: Comprehensive metadata, good plot text, high-res posters
3. **Fanart Third**: High-quality curated artwork (clearlogo, discart, etc.)

**Field Mapping** (OMDB → Database):

| OMDB Field | Database Field | Notes |
|------------|----------------|-------|
| `Title` | `title` | Fallback if TMDB missing |
| `Plot` | `plot` | Authoritative (OMDB first) |
| `imdbRating` | `imdb_rating` | **Exclusive** (OMDB only) |
| `imdbVotes` | `imdb_votes` | **Exclusive** (OMDB only) |
| `Ratings[source=Rotten Tomatoes]` | `rotten_tomatoes_score` | **Exclusive** (OMDB only) |
| `Ratings[source=Metacritic]` | `metacritic_score` | **Exclusive** (OMDB only) |
| `Awards` | `awards` | **Exclusive** (OMDB only) |
| `Rated` | `certification` | Fallback if TMDB missing |
| `Director` | `director` | String (not structured like TMDB) |
| `Writer` | `writer` | String (not structured like TMDB) |
| `Actors` | `actors` | String (not structured like TMDB) |

**Cast/Crew Handling**:
- TMDB provides structured cast/crew with person IDs → use for deduplication
- OMDB provides comma-separated strings → store as fallback fields
- Priority: TMDB structured data > OMDB string data

---

### 5. Completeness Tracking

**Calculate after each enrichment**:

```typescript
const EXPECTED_FIELDS = [
  'title', 'plot', 'tagline', 'imdb_rating', 'rotten_tomatoes_score',
  'metacritic_score', 'release_date', 'runtime', 'certification',
  'genres', 'poster_url'
];

function calculateCompleteness(movie: Movie): number {
  const filledFields = EXPECTED_FIELDS.filter(field =>
    movie[field] != null && movie[field] !== ''
  );

  return Math.round((filledFields.length / EXPECTED_FIELDS.length) * 100);
}

// After enrichment
await db.execute(
  'UPDATE movies SET completeness_pct = ?, last_enrichment_date = ? WHERE id = ?',
  [completeness, new Date(), movieId]
);
```

**UI Display**:
```
Movie: Inception
Completeness: ████████░░ 80% (8/10 fields)
Last Enriched: 2 days ago

Missing Fields:
  • Tagline (waiting for TMDB)
  • Awards (waiting for OMDB quota reset)
```

---

### 6. Rate Limit Detection (Provider-Specific)

**OMDB Detection**:
```typescript
function isOMDBRateLimitError(response: any): boolean {
  return (
    response.Response === 'False' &&
    (
      response.Error?.includes('Request limit reached') ||
      response.Error?.includes('Daily limit reached')
    )
  );
}

// In OMDBProvider
async fetchMetadata(params) {
  const response = await fetch(url);
  const data = await response.json();

  if (isOMDBRateLimitError(data)) {
    throw new RateLimitError('OMDB daily limit reached', 'omdb');
  }

  // ...
}
```

**TMDB Detection**:
```typescript
// TMDB uses standard HTTP 429
async fetchMetadata(params) {
  const response = await fetch(url);

  if (response.status === 429) {
    const retryAfter = response.headers.get('Retry-After');
    throw new RateLimitError('TMDB rate limited', 'tmdb', retryAfter);
  }

  // ...
}
```

**Unified Detection in Enrichment**:
```typescript
function isRateLimitError(error: unknown): boolean {
  // Check for RateLimitError class
  if (error instanceof RateLimitError) {
    return true;
  }

  // Check for OMDB-specific error message
  if (error instanceof ProviderError) {
    const message = error.message.toLowerCase();
    return (
      message.includes('request limit reached') ||
      message.includes('daily limit reached')
    );
  }

  return false;
}
```

---

## Database Schema Changes

### Minimal Schema Updates

```sql
-- Add completeness and enrichment tracking to movies
ALTER TABLE movies ADD COLUMN completeness_pct INTEGER DEFAULT 0;
ALTER TABLE movies ADD COLUMN last_enrichment_date TIMESTAMP;

-- Add new OMDB-specific fields
ALTER TABLE movies ADD COLUMN rotten_tomatoes_score INTEGER;
ALTER TABLE movies ADD COLUMN metacritic_score INTEGER;
ALTER TABLE movies ADD COLUMN awards TEXT;
ALTER TABLE movies ADD COLUMN outline TEXT;  -- OMDB short plot
ALTER TABLE movies ADD COLUMN director TEXT;  -- OMDB string (vs TMDB structured)
ALTER TABLE movies ADD COLUMN writer TEXT;
ALTER TABLE movies ADD COLUMN actors TEXT;

-- Same for series
ALTER TABLE series ADD COLUMN completeness_pct INTEGER DEFAULT 0;
ALTER TABLE series ADD COLUMN last_enrichment_date TIMESTAMP;
ALTER TABLE series ADD COLUMN rotten_tomatoes_score INTEGER;
ALTER TABLE series ADD COLUMN metacritic_score INTEGER;
ALTER TABLE series ADD COLUMN awards TEXT;
ALTER TABLE series ADD COLUMN outline TEXT;

-- Index for bulk enrichment queue (not staleness-based, just efficient iteration)
CREATE INDEX idx_movies_monitored ON movies(monitored, id);
CREATE INDEX idx_series_monitored ON series(monitored, id);
```

**No Complex Tables**:
- ❌ No field authorities table
- ❌ No source tracking table
- ❌ No enrichment history log (can add later if needed)

---

## Implementation

### Core Enrichment Function

```typescript
/**
 * Enrich a single movie
 *
 * @param movieId - Movie to enrich
 * @param requireComplete - If true, stop on rate limit (bulk mode)
 *                          If false, use partial data (single/webhook mode)
 */
async function enrichMovie(
  movieId: number,
  requireComplete: boolean
): Promise<{
  updated: boolean;
  partial: boolean;
  rateLimitedProviders: string[];
  changedFields?: string[];
}> {
  // Fetch from all enabled providers (parallel)
  const responses = await Promise.allSettled([
    omdbProvider.fetchMetadata({ movieId }),
    tmdbProvider.fetchMetadata({ movieId }),
    fanartProvider.fetchAssets({ movieId })
  ]);

  // Separate successful from rate-limited
  const successful: ProviderResponse[] = [];
  const rateLimited: string[] = [];

  for (const response of responses) {
    if (response.status === 'fulfilled') {
      if (response.value.rateLimited) {
        rateLimited.push(response.value.provider);
      } else {
        successful.push(response.value);
      }
    }
  }

  // BULK MODE: Stop if ANY provider rate-limited
  if (requireComplete && rateLimited.length > 0) {
    logger.info('[Enrich] Bulk mode - skipping due to rate limit', {
      movieId,
      rateLimitedProviders: rateLimited
    });

    return {
      updated: false,
      partial: false,
      rateLimitedProviders: rateLimited
    };
  }

  // SINGLE/WEBHOOK MODE: Use whatever we have
  if (successful.length === 0) {
    logger.warn('[Enrich] All providers failed', { movieId });
    return {
      updated: false,
      partial: false,
      rateLimitedProviders: rateLimited
    };
  }

  // Aggregate metadata with provider priority
  const aggregated = aggregateMetadata(successful);

  // Get current movie data
  const currentMovie = await db.movies.findById(movieId);

  // Build updates using "fill gaps, don't erase" logic
  const updates: Partial<Movie> = {};

  for (const [field, newValue] of Object.entries(aggregated)) {
    const currentValue = currentMovie[field];
    const isLocked = currentMovie[`${field}_locked`];

    if (shouldUpdateField(currentValue, newValue, isLocked)) {
      updates[field] = newValue;
    }
  }

  // Update database if we have changes
  if (Object.keys(updates).length > 0) {
    await db.movies.update(movieId, updates);

    // Update completeness
    const completeness = calculateCompleteness({ ...currentMovie, ...updates });
    await db.execute(
      'UPDATE movies SET completeness_pct = ?, last_enrichment_date = ? WHERE id = ?',
      [completeness, new Date(), movieId]
    );

    logger.info('[Enrich] Movie updated', {
      movieId,
      changedFields: Object.keys(updates),
      completeness
    });

    return {
      updated: true,
      partial: rateLimited.length > 0,
      rateLimitedProviders: rateLimited,
      changedFields: Object.keys(updates)
    };
  }

  logger.info('[Enrich] No changes needed', { movieId });
  return {
    updated: false,
    partial: false,
    rateLimitedProviders: rateLimited
  };
}
```

---

### Scheduled Bulk Enrichment Job

```typescript
/**
 * Bulk enrichment job
 * Runs daily at 3am
 * Processes ALL monitored movies until rate limit detected
 */
export class EnrichAllScheduler {
  constructor(
    private readonly db: DatabaseConnection,
    private readonly enrichmentService: EnrichmentService
  ) {}

  async enrichALL(): Promise<{
    processed: number;
    updated: number;
    skipped: number;
    stopped: boolean;
    stopReason: string | null;
  }> {
    logger.info('[EnrichALL] Starting bulk enrichment');

    const stats = {
      processed: 0,
      updated: 0,
      skipped: 0,
      stopped: false,
      stopReason: null as string | null
    };

    // Get ALL monitored movies
    const movies = await this.db.query<{ id: number; title: string }>(
      'SELECT id, title FROM movies WHERE monitored = 1 ORDER BY id ASC'
    );

    logger.info('[EnrichALL] Found movies to process', { count: movies.length });

    for (const movie of movies) {
      try {
        // Enrich with requireComplete = true
        const result = await this.enrichmentService.enrichMovie(movie.id, true);

        stats.processed++;

        // Check if we hit rate limit
        if (result.rateLimitedProviders.length > 0 && !result.updated) {
          // Rate limited and didn't update = STOP
          stats.stopped = true;
          stats.stopReason = `Provider rate limited: ${result.rateLimitedProviders[0]}`;

          logger.warn('[EnrichALL] Stopping bulk enrichment', {
            provider: result.rateLimitedProviders[0],
            processed: stats.processed,
            totalMovies: movies.length,
            percentComplete: Math.round((stats.processed / movies.length) * 100)
          });
          break;
        }

        if (result.updated) {
          stats.updated++;
        } else {
          stats.skipped++;
        }

        // Log progress every 100 movies
        if (stats.processed % 100 === 0) {
          logger.info('[EnrichALL] Progress update', {
            processed: stats.processed,
            updated: stats.updated,
            total: movies.length
          });
        }

      } catch (error) {
        logger.error('[EnrichALL] Movie enrichment failed', {
          movieId: movie.id,
          title: movie.title,
          error: getErrorMessage(error)
        });
        // Continue to next movie (transient errors don't stop job)
      }
    }

    logger.info('[EnrichALL] Bulk enrichment complete', stats);
    return stats;
  }

  /**
   * Schedule daily job
   */
  schedule() {
    // Cron: 0 3 * * * (3am daily)
    cron.schedule('0 3 * * *', async () => {
      try {
        await this.enrichALL();
      } catch (error) {
        logger.error('[EnrichALL] Job failed', {
          error: getErrorMessage(error)
        });
      }
    });

    logger.info('[EnrichALL] Scheduled daily job at 3am');
  }
}
```

---

### Webhook Handler

```typescript
/**
 * Radarr webhook handler
 * Creates enrichment job (best attempt mode)
 */
async function handleRadarrWebhook(event: RadarrWebhookEvent) {
  logger.info('[Webhook] Radarr event received', {
    eventType: event.eventType,
    movieTitle: event.movie.title
  });

  if (event.eventType === 'Download') {
    // Find movie in database
    const movie = await findMovieByPath(event.movie.folderPath);

    if (!movie) {
      logger.warn('[Webhook] Movie not found in database', {
        path: event.movie.folderPath
      });
      return;
    }

    // Create enrichment job (requireComplete = false)
    await jobQueue.enqueue('enrich-movie', {
      entityType: 'movie',
      entityId: movie.id,
      requireComplete: false,  // Best attempt (partial OK)
      source: 'webhook',
      priority: 'user'  // Higher priority than bulk job
    });

    logger.info('[Webhook] Enrichment job created', {
      movieId: movie.id,
      movieTitle: movie.title
    });
  }
}
```

---

### Job Queue Processor

```typescript
/**
 * Job queue processor for enrichment jobs
 */
async function processEnrichmentJob(job: Job<{
  entityType: 'movie' | 'series';
  entityId: number;
  requireComplete: boolean;
  source: 'webhook' | 'manual' | 'scheduled';
  priority: 'user' | 'automation' | 'background';
}>) {
  const { entityType, entityId, requireComplete, source } = job.data;

  logger.info('[Job] Processing enrichment job', {
    entityType,
    entityId,
    requireComplete,
    source
  });

  // Enrich movie/series
  const result = await enrichmentService.enrichMovie(entityId, requireComplete);

  if (result.updated) {
    logger.info('[Job] Enrichment successful', {
      entityId,
      partial: result.partial,
      changedFields: result.changedFields
    });

    // Trigger next pipeline phases
    if (result.changedFields && hasSignificantChanges(result.changedFields)) {
      await jobQueue.enqueue('publishing', { entityType, entityId });
      await jobQueue.enqueue('player-sync', { entityType, entityId });
    }

  } else if (result.rateLimitedProviders.length > 0) {
    logger.info('[Job] Enrichment skipped - rate limited', {
      entityId,
      providers: result.rateLimitedProviders
    });

  } else {
    logger.info('[Job] No changes made', { entityId });
  }
}

function hasSignificantChanges(changedFields: string[]): boolean {
  const SIGNIFICANT_FIELDS = [
    'title', 'plot', 'poster_url', 'fanart_url',
    'imdb_rating', 'release_date'
  ];

  return changedFields.some(f => SIGNIFICANT_FIELDS.includes(f));
}
```

---

## API Endpoints

### Manual Enrichment

```
POST /api/movies/:id/enrich
```

**Request**:
```json
{
  "forceRefresh": true
}
```

**Response**:
```json
{
  "success": true,
  "message": "Movie enriched successfully",
  "completeness": 90,
  "previousCompleteness": 80,
  "changedFields": ["imdb_rating", "rotten_tomatoes_score", "awards"],
  "rateLimitedProviders": []
}
```

**Response (Partial)**:
```json
{
  "success": true,
  "message": "Movie enriched (partial data - OMDB rate limited)",
  "completeness": 85,
  "previousCompleteness": 80,
  "changedFields": ["plot", "poster_url"],
  "rateLimitedProviders": ["omdb"]
}
```

---

### Completeness Report

```
GET /api/movies/completeness
```

**Response**:
```json
{
  "summary": {
    "total": 1000,
    "complete": 650,
    "partial": 300,
    "minimal": 50,
    "avgCompleteness": 87
  },
  "topIncomplete": [
    {
      "id": 456,
      "title": "Inception",
      "completeness": 60,
      "missingFields": ["tagline", "awards", "rotten_tomatoes_score"]
    }
  ]
}
```

---

### Bulk Enrichment Status

```
GET /api/enrichment/status
```

**Response**:
```json
{
  "lastRun": "2025-11-22T03:00:00Z",
  "nextRun": "2025-11-23T03:00:00Z",
  "lastRunStats": {
    "processed": 542,
    "updated": 487,
    "skipped": 55,
    "stopped": true,
    "stopReason": "Provider rate limited: omdb"
  }
}
```

---

## Implementation Phases

### Phase 1: Core "Fill Gaps" Logic

**Duration**: 3-4 days

**Tasks**:
1. Implement `shouldUpdateField()` function
2. Implement `calculateCompleteness()` function
3. Add database columns and indexes
4. Update `EnrichmentService.enrichMovie()` to use new logic
5. Add `requireComplete` parameter
6. Unit tests for field update rules

**Deliverables**:
- `src/services/enrichment/FieldUpdateLogic.ts`
- `src/services/enrichment/EnrichmentService.ts` (updated)
- Migration: `src/database/migrations/20251122_002_completeness_tracking.ts`
- Tests: `tests/services/FieldUpdateLogic.test.ts`

**Success Criteria**:
- ✅ Null never overwrites value
- ✅ Value updates when different
- ✅ Locked fields respected
- ✅ Completeness calculated correctly
- ✅ Tests pass

---

### Phase 2: OMDB Integration

**Duration**: 3-4 days

**Tasks**:
1. Add OMDB rate limit detection (response body check)
2. Add new database fields (RT, Metacritic, awards, outline)
3. Wire OMDB into enrichment flow
4. Add OMDB to provider priority list
5. Update field mapping
6. Integration tests with OMDB + TMDB

**Deliverables**:
- `src/services/providers/OMDBProvider.ts` (updated)
- Enhanced `EnrichmentService` with OMDB
- Migration for new fields
- Tests: `tests/providers/OMDBProvider.test.ts` (updated)

**Success Criteria**:
- ✅ OMDB queried during enrichment
- ✅ Rate limit detected correctly (response body check)
- ✅ IMDb ratings populated
- ✅ RT/Metacritic scores populated
- ✅ Awards field populated
- ✅ Graceful handling when rate limited

---

### Phase 3: Bulk Enrichment Scheduler

**Duration**: 2-3 days

**Tasks**:
1. Implement `EnrichAllScheduler` class
2. Add cron scheduling (3am daily)
3. Implement dynamic batch processing (process until rate limit)
4. Add progress logging
5. Integration tests for bulk job

**Deliverables**:
- `src/services/enrichment/EnrichAllScheduler.ts`
- Cron schedule initialization
- Tests: `tests/services/EnrichAllScheduler.test.ts`

**Success Criteria**:
- ✅ Job runs on schedule
- ✅ Processes all movies until rate limit
- ✅ Stops immediately when rate limit detected
- ✅ Resumes next day from where it stopped (via cache)
- ✅ Adapts to API tier automatically

---

### Phase 4: Webhook & Job Queue Integration

**Duration**: 2-3 days

**Tasks**:
1. Update webhook handlers to use `requireComplete: false`
2. Update job queue processor
3. Add pipeline phase triggers (publishing, player sync)
4. Integration tests for webhook flow

**Deliverables**:
- `src/controllers/webhooks/RadarrWebhookController.ts` (updated)
- `src/services/jobs/EnrichmentJobProcessor.ts` (updated)
- Tests: Webhook → enrichment → pipeline flow

**Success Criteria**:
- ✅ Webhook creates job correctly
- ✅ Job uses best attempt mode (partial OK)
- ✅ Pipeline phases triggered on significant changes
- ✅ Manual enrichment uses best attempt mode

---

### Phase 5: UI Implementation

**Duration**: 4-5 days

**Tasks**:
1. Completeness dashboard widget
2. Movie detail enrichment status
3. Missing fields display
4. Bulk enrichment status page
5. Manual force refresh button

**Deliverables**:
- `public/frontend/src/components/CompletnessDashboard.tsx`
- `public/frontend/src/components/EnrichmentStatus.tsx`
- Enhanced movie detail metadata tab
- Settings → Enrichment status page

**Success Criteria**:
- ✅ Users see completeness %
- ✅ Users see missing fields
- ✅ Users see bulk job status
- ✅ Force refresh works
- ✅ Partial enrichment warnings shown

---

### Phase 6: Testing & Documentation

**Duration**: 2-3 days

**Tasks**:
1. Performance testing (1000+ movies)
2. Provider failure simulation
3. Documentation updates (user + developer)
4. UI polish and loading states

**Deliverables**:
- Performance benchmarks
- Updated documentation
- Production-ready code

**Success Criteria**:
- ✅ 1000 movies enriched efficiently
- ✅ Provider failures handled gracefully
- ✅ Completeness tracking accurate
- ✅ Docs updated

---

## Testing Strategy

### Unit Tests

1. **Field Update Logic**
   ```typescript
   describe('shouldUpdateField', () => {
     it('fills gaps (null → value)');
     it('prevents regression (value → null)');
     it('allows changes (value1 → value2)');
     it('respects locks');
   });
   ```

2. **Completeness Calculation**
   ```typescript
   describe('calculateCompleteness', () => {
     it('calculates percentage correctly');
     it('handles empty movies');
     it('handles complete movies');
   });
   ```

3. **Rate Limit Detection**
   ```typescript
   describe('isRateLimitError', () => {
     it('detects OMDB rate limit (response body)');
     it('detects TMDB rate limit (HTTP 429)');
     it('ignores other errors');
   });
   ```

### Integration Tests

1. **Multi-Provider Enrichment**
   - All providers succeed → metadata merged
   - OMDB rate-limited → TMDB fills gaps
   - All providers fail → movie skipped

2. **Bulk Job Flow**
   - Processes movies until rate limit
   - Stops immediately when detected
   - Resumes next day via cache

3. **Webhook Flow**
   - Webhook creates job
   - Job uses best attempt mode
   - Pipeline phases triggered

### Manual Testing

1. **Completeness Dashboard**
   - Displays stats correctly
   - Shows incomplete movies
   - Updates after enrichment

2. **Provider Failures**
   - Simulate OMDB rate limit
   - Verify TMDB still works
   - Check no data loss

3. **Bulk Job**
   - Run scheduled job
   - Verify stops on rate limit
   - Check logs for progress

---

## Success Criteria

### Functional Requirements

- ✅ Never regress (value → null never happens)
- ✅ Fill gaps over time
- ✅ Completeness tracking accurate
- ✅ OMDB integrated and working
- ✅ Provider failures don't block system
- ✅ Scheduled job adapts to API tier
- ✅ Webhook enrichment works (best attempt)
- ✅ Manual enrichment works (best attempt)

### Performance Requirements

- ✅ Bulk job processes movies efficiently (cache-aware)
- ✅ Completeness calculation < 10ms per movie
- ✅ Rate limit detection immediate (1 request wasted max)
- ✅ Cache reduces API calls by 85%+ after initial run

### User Experience Requirements

- ✅ Users see completeness %
- ✅ Users see missing fields
- ✅ Users understand when data is partial
- ✅ Force refresh works instantly
- ✅ No data loss during provider failures

---

## Risk Analysis

### High Risk

**1. OMDB Rate Limit Exhaustion (Free Tier)**
- **Risk**: Free tier exhausted quickly during initial scan
- **Mitigation**:
  - Cache reduces subsequent runs to ~143 API calls/day
  - Bulk job stops when limit hit (doesn't waste requests)
  - Users can upgrade to paid tier ($1/month for 100k)

**2. OMDB API Changes**
- **Risk**: OMDB changes response format
- **Mitigation**:
  - Comprehensive error handling
  - Tests validate response structure
  - Fallback to TMDB if OMDB fails

### Medium Risk

**3. Bulk Job Never Completing (Large Libraries + Free Tier)**
- **Risk**: 10K+ library on free tier → never enriches all movies
- **Mitigation**:
  - Cache ensures rotation (all movies eventually enriched)
  - Manual enrichment always works (bypass bulk job)
  - Users can upgrade API tier

### Low Risk

**4. Unknown OMDB Reset Time**
- **Risk**: Can't optimize bulk job timing
- **Mitigation**:
  - Daily job "finds" optimal time naturally
  - Cache minimizes wasted requests
  - Acceptable trade-off for simplicity

---

## Rollback Plan

### Phase 1-2 (Core + OMDB)
- **Rollback**: Revert migration, remove OMDB integration
- **Impact**: Enrichment continues with TMDB only

### Phase 3 (Bulk Job)
- **Rollback**: Disable cron schedule
- **Impact**: Manual enrichment still works

### Phase 4 (Webhooks)
- **Rollback**: Revert webhook handler changes
- **Impact**: Webhooks still create jobs, use old logic

### Phase 5-6 (UI + Testing)
- **Rollback**: Revert frontend changes
- **Impact**: Backend still works, UI shows old interface

---

## Documentation Updates

### User Documentation

1. **Getting Started** - Add OMDB API key setup (optional)
2. **Enrichment** - Explain completeness tracking, bulk job behavior
3. **Troubleshooting** - Provider rate limits, partial enrichment

### Developer Documentation

1. **Architecture** - Document "fill gaps" logic, two-mode enrichment
2. **Providers** - Add OMDB integration details, rate limit detection
3. **Enrichment** - Update flow diagrams with new logic

---

## Key Design Principles

1. **Simplicity**: No complex state machines, no field authority tables
2. **Resilience**: Graceful degradation, no blocking failures
3. **Adaptability**: Test-based rate limits, cache-aware processing
4. **User Control**: Manual override always works, field locks respected
5. **No Configuration**: System adapts automatically to API tiers

---

**End of Specification**
